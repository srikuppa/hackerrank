void backtrack(const vector<pair<int, int>> &unique_items,
               int index,               // index of the item to consider
               int &min_num,            // size of global result
               int &cur_sum,            // sum of all items in cur_result
               int &max_sum,            // sum of global result
               int limit,               // sum threshold, always sum/2+1
               vector<int> &cur_result, // current list
               vector<int> &output)     // global list
{
    if (cur_sum >= limit)
    {
        if (cur_result.size() < min_num)
        {
            min_num = cur_result.size();
            max_sum = cur_sum;
            output = cur_result;
        }
        else if (cur_result.size() == min_num && cur_sum > max_sum)
        {
            // the subset A we found has the same size with the global
            // update it to maxmize the total weight
            max_sum = cur_sum;
            output = cur_result;
        }
        return;
    }

    for (int i = index; i < unique_items.size(); ++i)
    {
        // add current element
        vector<int> new_items(unique_items[i].second,
                              unique_items[i].first);
        cur_result.insert(cur_result.end(),
                          new_items.begin(),
                          new_items.end());
        cur_sum += unique_items[i].first * unique_items[i].second;

        backtrack(unique_items, i + 1, min_num, cur_sum, max_sum, limit,
                  cur_result, output);

        // restore cur_result
        cur_result.resize(cur_result.size() - unique_items[i].second);
        cur_sum -= unique_items[i].first * unique_items[i].second;
    }
}
